"""
Control the Gecko-Profiler Add-on by sending commands to Web Socket server.
"""

import os
import json
import time
import logging
from websocket import create_connection

from server import commands

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

CURRENT_PATH = os.path.dirname(os.path.abspath(__file__))
ONE_MINUTE = 60
ONE_HOUR = 60 * 60


class ControllerClient:

    def __init__(self, control_server=None, save_path=None, url=None):
        self.hostname = 'ws://localhost:8888/py'
        self.control_server = control_server
        self.is_online = False
        self.profiling = False
        self.ws_conn = None
        # default retry time 5
        self.retry_time = 5
        if save_path:
            self.save_path = save_path
        else:
            self.save_path = CURRENT_PATH
        if not save_path.endswith(os.sep):
            self.save_path += os.sep
        self.url = url

    def set_retry_time(self, retry_time):
        if isinstance(retry_time, int) and 0 < retry_time <= 100:
            self.retry_time = retry_time
        else:
            logger.warn('Can not set retry_time to {}. (0 < retry_time <= 100)')

    def set_save_path(self, path):
        self.save_path = path

    def _ping_addon(self):
        # wait for 1 min for ping add-on
        self.ws_conn.settimeout(ONE_MINUTE)
        data = {
            commands.KEY_NAME: commands.VALUE_PING_ADDON,
            commands.KEY_DATA: ''
        }
        # retry 60 times for ping
        ping_time = 60
        for _ in range(ping_time):
            ret_code, _ = self._send_and_recv(data)
            if ret_code == commands.REPLY_STAT_SUCCESS:
                self.profiling = True
                return True
            logger.debug('Retrying ...')
            time.sleep(1)
        logger.error('Cannot reach add-on.')
        return False

    def connect(self):
        logger.info('Connecting Web Socket server {} ...'.format(self.hostname))
        self.ws_conn = create_connection(self.hostname, header=["Sec-WebSocket-Protocol: geckoprofiler-url, "+self.url])
        self.is_online = True

        # wait for add-on online
        ret_status = self._ping_addon()
        if not ret_status:
            # offline if there is no add-on
            self.is_online = False

    def disconnect(self):
        self.ws_conn.close()

    def _force_stop_server(self):
        if self.control_server:
            self.control_server.stop_server()
        else:
            logger.warn('Cannot force stop Web Socket server.')

    def send_stop_server_command(self):
        logger.info('Stopping Web Socket server ...')
        data = {
            commands.KEY_NAME: commands.VALUE_STOP,
            commands.KEY_DATA: ''
        }
        self._send(data)
        self.is_online = False
        self.profiling = False
        logger.info('Stopped.')

    def start_profiler(self):
        self.ws_conn.settimeout(ONE_MINUTE)
        logger.info('Starting profiler ...')
        data = {
            commands.KEY_NAME: commands.VALUE_START,
            commands.KEY_DATA: ''
        }
        for _ in range(self.retry_time):
            ret_code, _ = self._send_and_recv(data)
            if ret_code == commands.REPLY_STAT_SUCCESS:
                self.profiling = True
                return True
            logger.debug('Retrying ...')
        logger.error("Cannot start profiler ...")
        return False

    def capture_profile(self, threshold):
        self.ws_conn.settimeout(ONE_MINUTE)
        logger.info('Capturing profile ...')
        data = {
            commands.KEY_NAME: commands.VALUE_CAPTURE,
            commands.KEY_DATA: threshold
        }
        if self.profiling:
            for _ in range(self.retry_time):
                ret_code, ret_msg = self._send_and_recv(data)
                if ret_code == commands.REPLY_STAT_SUCCESS:
                    return ret_msg
                logger.debug('Retrying ...')
            logger.error('Cannot capture profile.')
        else:
            logger.error('Profiler is not ready.')

    def stop_profiler(self):
        self.ws_conn.settimeout(ONE_MINUTE)
        logger.info('Stopping profiler ...')
        data = {
            commands.KEY_NAME: commands.VALUE_STOP,
            commands.KEY_DATA: ''
        }
        for _ in range(self.retry_time):
            ret_code, _ = self._send_and_recv(data)
            if ret_code == commands.REPLY_STAT_SUCCESS:
                self.profiling = False
                return True
            logger.debug('Retrying ...')
        logger.error("Cannot stop profiler ...")
        return False

    def _send_and_recv(self, data):
        self._send(data)
        return self._recv()

    def _send(self, data):
        if not self.is_online:
            raise Exception('The client is not connected to the server.')
        if isinstance(data, dict):
            message = json.dumps(data)
        else:
            message = data
        logger.debug('Sending {} ...'.format(message))
        self.ws_conn.send(message)
        logger.debug('Sent.')

    def _recv(self):
        if not self.is_online:
            raise Exception('The client is not connected to the server.')
        logger.debug('Receiving ...')
        try:
            result = self.ws_conn.recv()
            logger.debug('Received {}'.format(result))
            try:
                result_dict = json.loads(result)
                ret_code = result_dict.get(commands.KEY_NAME, 0)
                ret_message = result_dict.get(commands.KEY_DATA, '')
                return ret_code, ret_message
            except:
                return commands.REPLY_STAT_FAIL, 'Cannot parse JSON: {}'.format(result)
        except:
            return commands.REPLY_STAT_FAIL, 'recv() timeout'
