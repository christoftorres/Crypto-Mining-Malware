function extractFaviconFromLibname(libname) {
  const url = new URL('/favicon.ico', libname);
  return url.href;
}

class CallTree {

  constructor(thread, callNodeTable, callNodeTimes, callNodeChildCount, rootTotalTime, rootCount, jsOnly, isIntegerInterval) {
    this._callNodeTable = callNodeTable;
    this._callNodeTimes = callNodeTimes;
    this._callNodeChildCount = callNodeChildCount;
    this._funcTable = thread.funcTable;
    this._resourceTable = thread.resourceTable;
    this._stringTable = thread.stringTable;
    this._rootTotalTime = rootTotalTime;
    this._rootCount = rootCount;
    this._nodes = new Map();
    this._children = new Map();
    this._jsOnly = jsOnly;
    this._isIntegerInterval = isIntegerInterval;
  }

  getRoots() {
    return this.getChildren(-1);
  }

  /**
   * Return an array of callNodeIndex for the children of the node with index callNodeIndex.
   * @param  {[type]} callNodeIndex [description]
   * @return {[type]}                [description]
   */
  getChildren(callNodeIndex) {
    var children = this._children.get(callNodeIndex);
    if (children === undefined) {
      const childCount = callNodeIndex === -1 ? this._rootCount : this._callNodeChildCount[callNodeIndex];
      children = [];
      for (
        var childCallNodeIndex = callNodeIndex + 1;
        childCallNodeIndex < this._callNodeTable.length &&
        children.length < childCount;
        childCallNodeIndex++
      ) {
        if (
          this._callNodeTable.prefix[childCallNodeIndex] === callNodeIndex &&
          this._callNodeTimes.totalTime[childCallNodeIndex] !== 0
        ) {
          children.push(childCallNodeIndex);
        }
      }
      children.sort(
        (a, b) =>
          this._callNodeTimes.totalTime[b] - this._callNodeTimes.totalTime[a]
      );
      this._children.set(callNodeIndex, children);
    }
    return children;
  }

  hasChildren(callNodeIndex) {
    return this.getChildren(callNodeIndex).length !== 0;
  }

  getParent(callNodeIndex) {
    return this._callNodeTable.prefix[callNodeIndex];
  }

  getDepth(callNodeIndex) {
    return this._callNodeTable.depth[callNodeIndex];
  }

  hasSameNodeIds(tree) {
    return this._callNodeTable === tree._callNodeTable;
  }

  /**
   * Return an object with information about the node with index callNodeIndex.
   * @param  {[type]} callNodeIndex [description]
   * @return {[type]}                [description]
   */
  getNode(callNodeIndex) {
    var node = this._nodes.get(callNodeIndex);
    if (node === undefined) {
      const funcIndex = this._callNodeTable.func[callNodeIndex];
      const funcName = this._stringTable.getString(this._funcTable.name[funcIndex]);
      const resourceIndex = this._funcTable.resource[funcIndex];
      const resourceType = this._resourceTable.type[resourceIndex];
      const isJS = this._funcTable.isJS[funcIndex];
      const libName = this._getOriginAnnotation(funcIndex);
      const precision = this._isIntegerInterval ? 0 : 1;
      const selfTime = this._callNodeTimes.selfTime[callNodeIndex];
      const formatNumber = this._isIntegerInterval ? _formatIntegerNumber : _formatDecimalNumber;
      node = {
        totalTime: formatNumber(
          this._callNodeTimes.totalTime[callNodeIndex]
        ),
        totalTimePercent: (100 *
          this._callNodeTimes.totalTime[callNodeIndex] /
          this._rootTotalTime).toFixed(precision),
        selfTime: selfTime === 0 ? 'â€”' : formatNumber(selfTime),
        name: funcName,
        lib: libName,
        // Dim platform pseudo-stacks.
        dim: !isJS && this._jsOnly,
        icon:
          resourceType === resourceTypes.webhost
            ? extractFaviconFromLibname(libName)
            : null,
      };
      this._nodes.set(callNodeIndex, node);
    }
    return node;
  }

  _getOriginAnnotation(funcIndex) {
    const fileNameIndex = this._funcTable.fileName[funcIndex];
    if (fileNameIndex !== null) {
      const fileName = this._stringTable.getString(fileNameIndex);
      const lineNumber = this._funcTable.lineNumber[funcIndex];
      if (lineNumber !== null) {
        return fileName + ':' + lineNumber;
      }
      return fileName;
    }

    const resourceIndex = this._funcTable.resource[funcIndex];
    const resourceNameIndex = this._resourceTable.name[resourceIndex];
    if (resourceNameIndex !== undefined) {
      return this._stringTable.getString(resourceNameIndex);
    }

    return '';
  }
}

function _getInvertedStackSelfTimes(thread, callNodeTable, sampleCallNodes, interval) {
  // Compute an array that maps the callNodeIndex to its root.
  const callNodeToRoot = new Int32Array(callNodeTable.length);
  for (
    var callNodeIndex = 0;
    callNodeIndex < callNodeTable.length;
    callNodeIndex++
  ) {
    const prefixCallNode = callNodeTable.prefix[callNodeIndex];
    if (prefixCallNode !== -1) {
      callNodeToRoot[callNodeIndex] = callNodeToRoot[prefixCallNode];
    } else {
      callNodeToRoot[callNodeIndex] = callNodeIndex;
    }
  }

  // Calculate the timing information by going through each sample.
  const callNodeSelfTime = new Float32Array(callNodeTable.length);
  const callNodeLeafTime = new Float32Array(callNodeTable.length);
  for (
    var sampleIndex = 0;
    sampleIndex < sampleCallNodes.length;
    sampleIndex++
  ) {
    const callNodeIndex = sampleCallNodes[sampleIndex];
    if (callNodeIndex !== null) {
      const rootIndex = callNodeToRoot[callNodeIndex];
      callNodeSelfTime[rootIndex] += interval;
      callNodeLeafTime[callNodeIndex] += interval;
    }
  }

  return { callNodeSelfTime, callNodeLeafTime };
}

/**
 * This is a helper function to get the stack timings for un-inverted call trees.
 */
function _getStackSelfTimes(thread, callNodeTable, sampleCallNodes, interval) {
  const callNodeSelfTime = new Float32Array(callNodeTable.length);

  for (
    var sampleIndex = 0;
    sampleIndex < sampleCallNodes.length;
    sampleIndex++
  ) {
    const callNodeIndex = sampleCallNodes[sampleIndex];
    if (callNodeIndex !== null) {
      callNodeSelfTime[callNodeIndex] += interval;
    }
  }

  return { callNodeSelfTime, callNodeLeafTime: callNodeSelfTime };
}

function getSampleCallNodes(samples, stackIndexToCallNodeIndex) {
  return samples.stack.map(stack => {
    return stack === null ? null : stackIndexToCallNodeIndex[stack];
  });
}

/**
 * This computes all of the count and timing information displayed in the calltree.
 * It takes into account both the normal tree, and the inverted tree.
 */
function computeCallTreeCountsAndTimings(thread, callNodeInfo, interval, invertCallstack) {
  const sampleCallNodes = getSampleCallNodes(
    thread.samples,
    callNodeInfo.stackIndexToCallNodeIndex
  );
  // Inverted trees need a different method for computing the timing.
  const { callNodeSelfTime, callNodeLeafTime } = invertCallstack
    ? _getInvertedStackSelfTimes(thread, callNodeInfo.callNodeTable, sampleCallNodes, interval)
    : _getStackSelfTimes(thread, callNodeInfo.callNodeTable, sampleCallNodes, interval);

  // Compute the following variables:
  const callNodeTotalTime = new Float32Array(callNodeInfo.callNodeTable.length);
  const callNodeChildCount = new Uint32Array(callNodeInfo.callNodeTable.length);
  var rootTotalTime = 0;
  var rootCount = 0;

  for (
    var callNodeIndex = callNodeInfo.callNodeTable.length - 1;
    callNodeIndex >= 0;
    callNodeIndex--
  ) {
    callNodeTotalTime[callNodeIndex] += callNodeLeafTime[callNodeIndex];
    if (callNodeTotalTime[callNodeIndex] === 0) {
      continue;
    }
    const prefixCallNode = callNodeInfo.callNodeTable.prefix[callNodeIndex];
    if (prefixCallNode === -1) {
      rootTotalTime += callNodeTotalTime[callNodeIndex];
      rootCount++;
    } else {
      callNodeTotalTime[prefixCallNode] += callNodeTotalTime[callNodeIndex];
      callNodeChildCount[prefixCallNode]++;
    }
  }

  return {
    callNodeTimes: {
      selfTime: callNodeSelfTime,
      totalTime: callNodeTotalTime,
    },
    callNodeChildCount,
    rootTotalTime,
    rootCount,
  };
}

function timeCode(label, codeAsACallback) {
  if (typeof performance !== 'undefined') {
    const start = performance.now();
    const result = codeAsACallback();
    const elapsed = Math.round(performance.now() - start);
    //console.log(label+' took '+elapsed+'ms to execute.');
    return result;
  }
  return codeAsACallback();
}

/**
 * An exported interface to get an instance of the CallTree class.
 * This handles computing timing information, and passing it all into
 * the CallTree constructor.
 */
function getCallTree(thread, interval, callNodeInfo, implementationFilter, invertCallstack) {
  return timeCode('getCallTree', () => {
    const {
      callNodeTimes,
      callNodeChildCount,
      rootTotalTime,
      rootCount,
    } = computeCallTreeCountsAndTimings(
      thread,
      callNodeInfo,
      interval,
      invertCallstack
    );

    const jsOnly = implementationFilter === 'js';
    const isIntegerInterval = Math.floor(interval) === interval;

    return new CallTree(
      thread,
      callNodeInfo.callNodeTable,
      callNodeTimes,
      callNodeChildCount,
      rootTotalTime,
      rootCount,
      jsOnly,
      isIntegerInterval
    );
  });
}

const LOCALE_WITH_DECIMAL_POINT = {
  minimumFractionDigits: 1,
  maximumFractionDigits: 1,
};

function _formatDecimalNumber(number) {
  return number.toLocaleString(undefined, LOCALE_WITH_DECIMAL_POINT);
}

function _formatIntegerNumber(number) {
  return number.toLocaleString();
}

/**
 * Generate the CallNodeInfo which contains the CallNodeTable, and a map to convert
 * an IndexIntoStackTable to a IndexIntoCallNodeTable. This function runs through
 * a stackTable, and de-duplicates stacks that have frames that point to the same
 * function.
 *
 * See `src/types/profile-derived.js` for the type definitions.
 * See `docs/call-trees.md` for a detailed explanation of CallNodes.
 */
function getCallNodeInfo(stackTable, frameTable, funcTable) {
  return timeCode('getCallNodeInfo', () => {
    const stackIndexToCallNodeIndex = new Uint32Array(stackTable.length);
    const funcCount = funcTable.length;
    // Maps can't key off of two items, so combine the prefixCallNode and the funcIndex
    // using the following formula: prefixCallNode * funcCount + funcIndex => callNode
    const prefixCallNodeAndFuncToCallNodeMap = new Map();

    // The callNodeTable components.
    var prefix = [];
    var func = [];
    var depth = [];
    var length = 0;

    function addCallNode(prefixIndex, funcIndex) {
      const index = length++;
      prefix[index] = prefixIndex;
      func[index] = funcIndex;
      if (prefixIndex === -1) {
        depth[index] = 0;
      } else {
        depth[index] = depth[prefixIndex] + 1;
      }
    }

    // Go through each stack, and create a new callNode table, which is based off of
    // functions rather than frames.
    for (var stackIndex = 0; stackIndex < stackTable.length; stackIndex++) {
      const prefixStack = stackTable.prefix[stackIndex];
      // We know that at this point the following condition holds:
      // assert(prefixStack === null || prefixStack < stackIndex);
      const prefixCallNode = prefixStack === null ? -1 : stackIndexToCallNodeIndex[prefixStack];
      const frameIndex = stackTable.frame[stackIndex];
      const funcIndex = frameTable.func[frameIndex];
      const prefixCallNodeAndFuncIndex = prefixCallNode * funcCount + funcIndex;
      var callNodeIndex = prefixCallNodeAndFuncToCallNodeMap.get(
        prefixCallNodeAndFuncIndex
      );
      if (callNodeIndex === undefined) {
        callNodeIndex = length;
        addCallNode(prefixCallNode, funcIndex);
        prefixCallNodeAndFuncToCallNodeMap.set(
          prefixCallNodeAndFuncIndex,
          callNodeIndex
        );
      }
      stackIndexToCallNodeIndex[stackIndex] = callNodeIndex;
    }

    const callNodeTable = {
      prefix: new Int32Array(prefix),
      func: new Int32Array(func),
      depth,
      length,
    };

    return { callNodeTable, stackIndexToCallNodeIndex };
  });
}
