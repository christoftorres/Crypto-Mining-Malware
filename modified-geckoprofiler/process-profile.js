const resourceTypes = {
  unknown: 0,
  library: 1,
  addon: 2,
  webhost: 3,
  otherhost: 4,
  url: 5,
};

class UniqueStringArray {

  constructor(originalArray) {
    this._array = originalArray.slice(0);
    this._stringToIndex = new Map();
    for (var i = 0; i < originalArray.length; i++) {
      this._stringToIndex.set(originalArray[i], i);
    }
  }

  getString(index) {
    if (!(index in this._array)) {
      throw new Error('index '+index+' not in UniqueStringArray');
    }
    return this._array[index];
  }

  indexForString(s) {
    var index = this._stringToIndex.get(s);
    if (index === undefined) {
      index = this._array.length;
      this._stringToIndex.set(s, index);
      this._array.push(s);
    }
    return index;
  }

  serializeToArray() {
    return this._array.slice(0);
  }
}

function _toStructOfArrays(geckoTable) {
  const result = { length: geckoTable.data.length };
  for (const fieldName in geckoTable.schema) {
    const fieldIndex = geckoTable.schema[fieldName];
    if (typeof fieldIndex !== 'number') {
      throw new Error(
        'fieldIndex must be a number in the Gecko profile table.'
      );
    }
    result[fieldName] = geckoTable.data.map(
      entry => (fieldIndex in entry ? entry[fieldIndex] : null)
    );
  }
  return result;
}

function _sortByField(fieldName, geckoTable) {
  const fieldIndex = geckoTable.schema[fieldName];
  const sortedData = geckoTable.data.slice(0);
  sortedData.sort((a, b) => a[fieldIndex] - b[fieldIndex]);
  return Object.assign({}, geckoTable, { data: sortedData });
}

function getContainingLibrary(libs, address) {
  if (isNaN(address)) {
    return null;
  }
  let left = 0;
  let right = libs.length - 1;
  while (left <= right) {
    const mid = ((left + right) / 2) | 0;
    if (address >= libs[mid].end) {
      left = mid + 1;
    } else if (address < libs[mid].start) {
      right = mid - 1;
    } else {
      return libs[mid];
    }
  }
  return null;
}

function _cleanFunctionName(functionName) {
  const ignoredPrefix = 'non-virtual thunk to ';
  if (functionName.startsWith && functionName.startsWith(ignoredPrefix)) {
    return functionName.substr(ignoredPrefix.length);
  }
  return functionName;
}

function _getRealScriptURI(url) {
  if (url) {
    const urls = url.split(' -> ');
    return urls[urls.length - 1];
  }
  return url;
}

function _extractFuncsAndResourcesFromFrames(geckoFrameStruct, stringTable, libs) {
  const funcTable = {
    length: 0,
    name: [],
    resource: [],
    address: [],
    isJS: [],
    fileName: [],
    lineNumber: [],
  };

  const resourceTable = {
    length: 0,
    type: [],
    name: [],
    lib: [],
    icon: [],
    addonId: [],
    host: [],
  };

  function addLibResource(name, libIndex) {
    const index = resourceTable.length++;
    resourceTable.type[index] = resourceTypes.library;
    resourceTable.name[index] = name;
    resourceTable.lib[index] = libIndex;
  }

  function addWebhostResource(origin, host) {
    const index = resourceTable.length++;
    resourceTable.type[index] = resourceTypes.webhost;
    resourceTable.name[index] = origin;
    resourceTable.host[index] = host;
  }

  function addUrlResource(url) {
    const index = resourceTable.length++;
    resourceTable.type[index] = resourceTypes.url;
    resourceTable.name[index] = url;
  }

  const libToResourceIndex = new Map();
  const originToResourceIndex = new Map();
  const libNameToResourceIndex = new Map();
  const stringTableIndexToNewFuncIndex = new Map();

  const frameFuncs = geckoFrameStruct.location.map(locationIndex => {
    var funcIndex = stringTableIndexToNewFuncIndex.get(locationIndex);
    if (funcIndex !== undefined) {
      return funcIndex;
    }
    var funcNameIndex = locationIndex;
    var resourceIndex = -1;
    var addressRelativeToLib = -1;
    var isJS = false;
    var fileName = null;
    var lineNumber = null;
    const locationString = stringTable.getString(funcNameIndex);
    if (locationString.startsWith('0x')) {
      const address = parseInt(locationString.substr(2), 16);
      const lib = getContainingLibrary(libs, address);
      if (lib) {
        addressRelativeToLib = address - lib.start;
        // Flow doesn't understand Map.prototype.has()
        const maybeResourceIndex = libToResourceIndex.get(lib);
        if (maybeResourceIndex === undefined) {
          resourceIndex = resourceTable.length;
          libToResourceIndex.set(lib, resourceIndex);
          const nameStringIndex = stringTable.indexForString(lib.debugName);
          addLibResource(nameStringIndex, libs.indexOf(lib));
        } else {
          resourceIndex = maybeResourceIndex;
        }
      }
    } else {
      const cppMatch =
        /^(.*) \(in ([^)]*)\) (\+ [0-9]+)$/.exec(locationString) ||
        /^(.*) \(in ([^)]*)\) (\(.*:.*\))$/.exec(locationString) ||
        /^(.*) \(in ([^)]*)\)$/.exec(locationString);
      if (cppMatch) {
        funcNameIndex = stringTable.indexForString(
          _cleanFunctionName(cppMatch[1])
        );
        const libraryNameStringIndex = stringTable.indexForString(cppMatch[2]);
        funcIndex = stringTableIndexToNewFuncIndex.get(funcNameIndex);
        if (funcIndex !== undefined) {
          return funcIndex;
        }
        const maybeResourceIndex = libNameToResourceIndex.get(
          libraryNameStringIndex
        );
        if (maybeResourceIndex === undefined) {
          resourceIndex = resourceTable.length;
          libNameToResourceIndex.set(libraryNameStringIndex, resourceIndex);
          addLibResource(libraryNameStringIndex, -1);
        } else {
          resourceIndex = maybeResourceIndex;
        }
      } else {
        const jsMatch =
          /^(.*) \((.*):([0-9]+)\)$/.exec(locationString) ||
          /^()(.*):([0-9]+)$/.exec(locationString);
        if (jsMatch) {
          isJS = true;
          const scriptURI = _getRealScriptURI(jsMatch[2]);
          let origin, host;
          try {
            const url = new URL(scriptURI);
            if (!(url.protocol === 'http:' || url.protocol === 'https:')) {
              throw new Error('not a webhost protocol');
            }
            origin = url.origin;
            host = url.host;
          } catch (e) {
            origin = scriptURI;
            host = null;
          }
          const maybeResourceIndex = originToResourceIndex.get(origin);
          if (maybeResourceIndex === undefined) {
            resourceIndex = resourceTable.length;
            originToResourceIndex.set(origin, resourceIndex);
            const originStringIndex = stringTable.indexForString(origin);
            if (host) {
              const hostIndex = stringTable.indexForString(host);
              addWebhostResource(originStringIndex, hostIndex);
            } else {
              const urlStringIndex = stringTable.indexForString(scriptURI);
              addUrlResource(urlStringIndex);
            }
          } else {
            resourceIndex = maybeResourceIndex;
          }

          if (jsMatch[1]) {
            funcNameIndex = stringTable.indexForString(jsMatch[1]);
          } else {
            // Some JS frames don't have a function because they are for the
            // initial evaluation of the whole JS file. In that case, use the
            // file name itself, prepended by '(root scope) ', as the function
            // name.
            funcNameIndex = stringTable.indexForString(
              '(root scope) '+scriptURI
            );
          }
          fileName = stringTable.indexForString(scriptURI);
          lineNumber = parseInt(jsMatch[3], 10);
        }
      }
    }
    funcIndex = funcTable.length;
    {
      // Add the function to the funcTable.
      const index = funcTable.length++;
      funcTable.name[index] = funcNameIndex;
      funcTable.resource[index] = resourceIndex;
      funcTable.address[index] = addressRelativeToLib;
      funcTable.isJS[index] = isJS;
      funcTable.fileName[index] = fileName;
      funcTable.lineNumber[index] = lineNumber;
    }
    stringTableIndexToNewFuncIndex.set(locationIndex, funcIndex);
    return funcIndex;
  });

  return [funcTable, resourceTable, frameFuncs];
}

function _processFrameTable(geckoFrameStruct, funcTable, frameFuncs) {
  return {
    address: frameFuncs.map(funcIndex => funcTable.address[funcIndex]),
    category: geckoFrameStruct.category,
    func: frameFuncs,
    implementation: geckoFrameStruct.implementation,
    line: geckoFrameStruct.line,
    optimizations: geckoFrameStruct.optimizations,
    length: geckoFrameStruct.length,
  };
}

function _processStackTable(geckoStackTable) {
  return {
    frame: geckoStackTable.frame,
    prefix: geckoStackTable.prefix,
    length: geckoStackTable.length,
  };
}

function _processMarkers(geckoMarkers) {
  return {
    data: geckoMarkers.data,
    name: geckoMarkers.name,
    time: geckoMarkers.time,
    length: geckoMarkers.length,
  };
}

function _processSamples(geckoSamples) {
  return {
    responsiveness: geckoSamples.responsiveness,
    stack: geckoSamples.stack,
    time: geckoSamples.time,
    rss: geckoSamples.rss,
    uss: geckoSamples.uss,
    length: geckoSamples.length,
  };
}

function _processThread(thread, profile) {
  const geckoFrameStruct = _toStructOfArrays(thread.frameTable);
  const geckoStackTable = _toStructOfArrays(thread.stackTable);
  const geckoSamples = _toStructOfArrays(thread.samples);
  const geckoMarkers = _toStructOfArrays(_sortByField('time', thread.markers));
  const { libs, pausedRanges, meta } = profile;
  const { shutdownTime } = meta;
  const stringTable = new UniqueStringArray(thread.stringTable);
  const [funcTable, resourceTable, frameFuncs] = _extractFuncsAndResourcesFromFrames(geckoFrameStruct, stringTable, libs);
  const frameTable = _processFrameTable(geckoFrameStruct, funcTable, frameFuncs);
  const stackTable = _processStackTable(geckoStackTable);
  const markers = _processMarkers(geckoMarkers);
  const samples = _processSamples(geckoSamples);
  return {
    name: thread.name,
    processType: thread.processType,
    processStartupTime: 0,
    processShutdownTime: shutdownTime,
    registerTime: thread.registerTime,
    unregisterTime: thread.unregisterTime,
    tid: thread.tid,
    pid: thread.pid,
    libs,
    pausedRanges,
    frameTable,
    funcTable,
    resourceTable,
    stackTable,
    markers,
    stringTable,
    samples,
  };
}

function _adjustSampleTimestamps(samples, delta) {
  return Object.assign({}, samples, {
    time: samples.time.map(time => time + delta),
  });
}

function _adjustMarkerTimestamps(markers, delta) {
  return Object.assign({}, markers, {
    time: markers.time.map(time => time + delta),
    data: markers.data.map(data => {
      if (!data) {
        return data;
      }
      const newData = immutableUpdate(data);
      if ('startTime' in newData) {
        newData.startTime += delta;
      }
      if ('endTime' in newData) {
        newData.endTime += delta;
      }
      if (newData.type === 'DOMEvent' && 'timeStamp' in newData) {
        newData.timeStamp += delta;
      }
      return newData;
    }),
  });
}

function immutableUpdate(object, rest) {
  return Object.assign({}, object, rest);
}

function processProfile(geckoProfile) {
  // Handle profiles from older versions of Gecko. This call might throw an
  // exception.
  //upgradeGeckoProfileToCurrentVersion(geckoProfile);
  console.log(JSON.stringify(geckoProfile));

  var threads = [];

  for (const thread of geckoProfile.threads) {
    threads.push(_processThread(thread, geckoProfile));
  }

  for (const subprocessProfile of geckoProfile.processes) {
    const subprocessLibs = subprocessProfile.libs;
    const adjustTimestampsBy = subprocessProfile.meta.startTime - geckoProfile.meta.startTime;
    threads = threads.concat(
      subprocessProfile.threads.map(thread => {
        const newThread = _processThread(thread, subprocessProfile);
        newThread.samples = _adjustSampleTimestamps(
          newThread.samples,
          adjustTimestampsBy
        );
        newThread.markers = _adjustMarkerTimestamps(
          newThread.markers,
          adjustTimestampsBy
        );
        newThread.processStartupTime += adjustTimestampsBy;
        if (newThread.processShutdownTime !== null) {
          newThread.processShutdownTime += adjustTimestampsBy;
        }
        newThread.registerTime += adjustTimestampsBy;
        if (newThread.unregisterTime !== null) {
          newThread.unregisterTime += adjustTimestampsBy;
        }
        return newThread;
      })
    );
  }

  const meta = {
    interval: geckoProfile.meta.interval,
    startTime: geckoProfile.meta.startTime,
    abi: geckoProfile.meta.abi,
    misc: geckoProfile.meta.misc,
    oscpu: geckoProfile.meta.oscpu,
    platform: geckoProfile.meta.platform,
    processType: geckoProfile.meta.processType,
    product: geckoProfile.meta.product,
    stackwalk: geckoProfile.meta.stackwalk,
    toolkit: geckoProfile.meta.toolkit,
    version: geckoProfile.meta.version,
  };

  const result = {
    meta,
    threads,
  };

  return result;
}
